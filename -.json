{
  "createdAt": "2025-06-11T14:16:38.482Z",
  "updatedAt": "2025-06-11T20:16:52.368Z",
  "id": "mt0gPsg4I9Zx1H5G",
  "name": "PDF Summary 4",
  "active": false,
  "isArchived": true,
  "nodes": [
    {
      "parameters": {
        "formTitle": "Submit PDF",
        "formDescription": "Submit pdf file",
        "formFields": {
          "values": [
            {
              "fieldLabel": "data",
              "fieldType": "file"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.formTrigger",
      "typeVersion": 2.2,
      "position": [
        -6500,
        3170
      ],
      "id": "7a6f5c0c-cd9f-46bd-914a-518df64df311",
      "name": "On form submission",
      "webhookId": "af1893fe-70d5-48a5-a1cf-774570738e29"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=Here is the PDF content: {{ $json.text }}\n\nPlease analyze this document and return **exactly** the following, with no extra commentary:\n\nTITLE: [Document title]\n\nYEAR: [Publication year]\n\nAUTHOR: [Author name(s)]\n\nPAGES: [Total page count]\n\nOVERVIEW (50 words):  \n[Write a 50-word overview of the document.]\n\nSUMMARY (300 words):  \n[Write a 300-word summary targeting \"White paper\" and the document title.]\n\nMETA DESCRIPTION (160 chars max):  \n[Write a meta description, no more than 160 characters.]\nDescribe your new note here.\n\nReview 1 (50 - 100 words):\n[Write a 150-word posotive review of the document.]",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2,
      "position": [
        -5840,
        2920
      ],
      "id": "4483e72a-b319-49b8-942e-6309f7181524",
      "name": "AI Agent",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "const input = $input.first();\nlet text = input.json.output || '';\n\n// Extract title from the AI output\nconst titleMatch = text.match(/TITLE: (.+)/);\nconst aiTitle = titleMatch ? titleMatch[1].trim() : 'Untitled';\n\n// Split text into chunks that fit Notion's 2000 char limit\nconst chunks = [];\nlet remainingText = text;\n\nwhile (remainingText.length > 0) {\n  let chunk = remainingText.substring(0, 1900);\n\n  // If there's more text, try to break at a natural point\n  if (remainingText.length > 1900) {\n    const lastPeriod = chunk.lastIndexOf('. ');\n    const lastNewline = chunk.lastIndexOf('\\n');\n\n    if (lastPeriod > 1200) {\n      chunk = chunk.substring(0, lastPeriod + 1);\n    } else if (lastNewline > 1200) {\n      chunk = chunk.substring(0, lastNewline);\n    }\n  }\n\n  chunks.push(chunk.trim());\n  remainingText = remainingText.substring(chunk.length).trim();\n}\n\n// Return all original data plus split blocks, extracted title, and coverImageFileName\nreturn [{\n  json: {\n    ...input.json,\n    aiTitle: aiTitle,\n    block1: chunks[0] || '',\n    block2: chunks[1] || '',\n    block3: chunks[2] || '',\n    coverImageFileName: input.json.coverImageFileName // <-- Make sure this line is here!\n  },\n  binary: input.binary || {}\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -5464,
        3020
      ],
      "id": "ed774bc4-5e47-4e61-b2fa-3d7d7a9df688",
      "name": "Process AI Output"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        -5244,
        3170
      ],
      "id": "ae9dd9d1-4319-414f-ab95-d869febe0bbf",
      "name": "Merge1"
    },
    {
      "parameters": {
        "jsCode": "// FIXED JavaScript Code for \"Add File name to JSON\" node:\nconst input = $input.first();\nlet fileName = 'output.png';\n\nconst binaryKey = Object.keys(input.binary)[0];\n\nif (binaryKey && input.binary[binaryKey]) {\n  // Generate a unique filename with timestamp and random string\n  const timestamp = Date.now();\n  const randomString = Math.random().toString(36).substring(2, 8);\n  const originalFileName = input.binary[binaryKey].fileName || 'output.png';\n  const fileExtension = originalFileName.split('.').pop() || 'png';\n  \n  fileName = `cover_${timestamp}_${randomString}.${fileExtension}`;\n}\n\n// Provide the COMPLETE path with unique filename\nconst completePath = \"ban/pdf_summary/\" + fileName;\n\n// Debug logging\nconsole.log('Generated fileName:', fileName);\nconsole.log('Complete path:', completePath);\nconsole.log('Binary key found:', binaryKey);\n\nreturn [{\n  json: {\n    ...input.json,\n    completePath: completePath,\n    uniqueFileName: fileName,\n    fileMeta: {\n      originalName: input.json.originalFileName || 'unknown.pdf',\n      processedAt: new Date().toISOString()\n    },\n    // Debug info\n    debug: {\n      binaryKey: binaryKey,\n      generatedPath: completePath\n    }\n  },\n  binary: input.binary\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -5762,
        3320
      ],
      "id": "31ce2578-7cc0-4958-b768-253bfc983c20",
      "name": "Add File name to JSON"
    },
    {
      "parameters": {
        "jsCode": "const input = $input.first();\n\n// Get the filename from coverImageFileName or generate a timestamp-based one\nconst fileName = input.json.coverImageFileName || `cover_${Date.now()}.png`;\nconst fullPath = `ban/pdf_summary/${fileName}`;\n\nreturn [{\n  json: {\n    ...input.json,\n    s3Url: `https://xaraban.s3.amazonaws.com/${fullPath}`\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -5464,
        3320
      ],
      "id": "eddbf7fe-238a-49a9-9fad-3143d43b3161",
      "name": "Add s3Url to JSON"
    },
    {
      "parameters": {
        "pageId": {
          "__rl": true,
          "value": "https://www.notion.so/PDF-Summary-2007112e57b980d8b998e19f93512ba1",
          "mode": "url"
        },
        "title": "={{ $json.aiTitle }}",
        "blockUi": {
          "blockValues": [
            {
              "textContent": "={{ $json.block1 }}"
            },
            {
              "textContent": "={{ $json.block2 }}"
            },
            {
              "textContent": "={{ $json.block3 }}"
            },
            {
              "textContent": "={{ $json.s3Url }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.notion",
      "typeVersion": 2.2,
      "position": [
        -5024,
        3170
      ],
      "id": "ca16936e-881b-45b6-bd09-ca111feba21d",
      "name": "Notion_good_urlonly",
      "credentials": {
        "notionApi": {
          "id": "wv5ZmtxyRwkU0dXZ",
          "name": "Notion account"
        }
      }
    },
    {
      "parameters": {
        "modelName": "models/gemini-2.5-flash-preview-05-20",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatGoogleGemini",
      "typeVersion": 1,
      "position": [
        -5880,
        3140
      ],
      "id": "3508fb08-8c13-483c-be23-09acaa96d20c",
      "name": "Google Gemini Chat Model",
      "credentials": {
        "googlePalmApi": {
          "id": "98JqTQmfb8tBNsCz",
          "name": "Google Gemini(PaLM) Api account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\n\nreturn items.map((item, index) => {\n  console.log(`=== PROCESSING ITEM ${index + 1} ===`);\n  console.log('Full item structure:', JSON.stringify(item, null, 2));\n  \n  let originalFileName = null;\n  let binaryData = {};\n  \n  // Method 1: Check if binary data exists and extract filename\n  if (item.binary && Object.keys(item.binary).length > 0) {\n    console.log('Binary data found. Keys:', Object.keys(item.binary));\n    \n    // Usually the form field name is 'data' for file uploads\n    const binaryKey = Object.keys(item.binary)[0]; // Get first binary key\n    console.log('Using binary key:', binaryKey);\n    \n    if (item.binary[binaryKey]) {\n      binaryData = {};\n      binaryData[binaryKey] = item.binary[binaryKey];\n      \n      // Extract filename from binary data\n      const binaryInfo = item.binary[binaryKey];\n      console.log('Binary info:', {\n        fileName: binaryInfo.fileName,\n        mimeType: binaryInfo.mimeType,\n        fileExtension: binaryInfo.fileExtension,\n        hasData: !!binaryInfo.data\n      });\n      \n      // Try multiple ways to get filename\n      originalFileName = binaryInfo.fileName || \n                       binaryInfo.filename || \n                       binaryInfo.name ||\n                       binaryInfo.originalname;\n      \n      console.log('Extracted filename:', originalFileName);\n    }\n  }\n  \n  // Method 2: Check form data structure\n  if (!originalFileName && item.json) {\n    console.log('Checking JSON structure for filename...');\n    \n    // Check if there's form data with filename\n    if (item.json.data && Array.isArray(item.json.data)) {\n      const fileField = item.json.data.find(field => \n        field.fieldName === 'data' || \n        field.fieldType === 'file' ||\n        field.filename ||\n        field.fileName\n      );\n      \n      if (fileField) {\n        originalFileName = fileField.filename || \n                         fileField.fileName || \n                         fileField.name;\n        console.log('Found filename in form data:', originalFileName);\n      }\n    }\n    \n    // Direct filename fields\n    if (!originalFileName) {\n      originalFileName = item.json.filename || \n                       item.json.fileName || \n                       item.json.originalFileName ||\n                       item.json.name;\n      console.log('Found filename in JSON:', originalFileName);\n    }\n  }\n  \n  // Method 3: Generate filename if still not found - BUT KEEP IT SIMPLE\n  if (!originalFileName || originalFileName === 'undefined' || originalFileName === '') {\n    console.log('No filename found, using default...');\n    // Use a simple default that won't cause issues\n    originalFileName = 'uploaded-document.pdf';\n    console.log('Using default filename:', originalFileName);\n  }\n  \n  // Clean up filename (remove any problematic characters but preserve original name structure)\n  // Only replace truly problematic characters, keep hyphens and underscores\n  originalFileName = originalFileName.replace(/[<>:\"/\\\\|?*]/g, '_');\n  \n  // Ensure .pdf extension\n  if (!originalFileName.toLowerCase().endsWith('.pdf')) {\n    const nameWithoutExt = originalFileName.split('.')[0];\n    originalFileName = nameWithoutExt + '.pdf';\n  }\n  \n  console.log('Final filename:', originalFileName);\n  \n  // Validation\n  const hasValidFilename = originalFileName && originalFileName !== 'undefined';\n  const hasValidBinary = Object.keys(binaryData).length > 0;\n  \n  console.log('Validation:');\n  console.log('- Valid filename:', hasValidFilename);\n  console.log('- Valid binary data:', hasValidBinary);\n  console.log('- Binary data keys:', Object.keys(binaryData));\n  \n  if (hasValidBinary) {\n    const firstBinaryKey = Object.keys(binaryData)[0];\n    console.log('- Binary data size:', binaryData[firstBinaryKey]?.data?.length || 'unknown');\n  }\n  \n  console.log('================================');\n  \n  return {\n    json: {\n      ...item.json,\n      originalFileName: originalFileName,\n      processingTimestamp: new Date().toISOString(),\n      validationStatus: {\n        hasFilename: hasValidFilename,\n        hasBinary: hasValidBinary,\n        readyForUpload: hasValidFilename && hasValidBinary\n      },\n      extractionMethod: 'enhanced_extraction_v3'\n    },\n    binary: binaryData\n  };\n});"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -6280,
        3020
      ],
      "id": "d54dbdea-538d-4871-826c-fede856d0bb9",
      "name": "Binary Data Extraction"
    },
    {
      "parameters": {
        "operation": "pdf",
        "options": {}
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        -6060,
        3020
      ],
      "id": "635de3dc-f7e1-432a-88bd-372196fc0c9b",
      "name": "Extract from File1",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "operation": "Convert from PDF",
        "url": "https://www.dropbox.com/scl/fi/i773uqsbd3wsryxbjuutv/n8n_png_upload?rlkey=q8y2otunq5j99k1x49ksa545l&st=w25wp9aj&dl=0",
        "convertType": "toPng",
        "advancedOptions_Image": {}
      },
      "type": "n8n-nodes-pdfco.PDFco Api",
      "typeVersion": 1,
      "position": [
        -6060,
        3320
      ],
      "id": "1c200134-e871-44b4-a69d-7fcc305c252a",
      "name": "PDFco Api",
      "credentials": {
        "pdfcoApi": {
          "id": "PAcs9bTz82LKZSjr",
          "name": "PDF.co account"
        }
      }
    },
    {
      "parameters": {
        "path": "png_8n8"
      },
      "type": "n8n-nodes-base.dropbox",
      "typeVersion": 1,
      "position": [
        -6240,
        3320
      ],
      "id": "3358abf6-2f02-48f8-80e3-00984265742b",
      "name": "Dropbox",
      "credentials": {
        "dropboxApi": {
          "id": "7S85Xl3wT16hm4L2",
          "name": "Dropbox account"
        }
      }
    },
    {
      "parameters": {
        "operation": "pdf",
        "options": {
          "maxPages": 1
        }
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        -6420,
        3400
      ],
      "id": "d8fbb108-7547-465f-97e6-340433bae492",
      "name": "Extract from File",
      "alwaysOutputData": true
    }
  ],
  "connections": {
    "On form submission": {
      "main": [
        [
          {
            "node": "Binary Data Extraction",
            "type": "main",
            "index": 0
          },
          {
            "node": "Extract from File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent": {
      "main": [
        [
          {
            "node": "Process AI Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process AI Output": {
      "main": [
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge1": {
      "main": [
        [
          {
            "node": "Notion_good_urlonly",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Add File name to JSON": {
      "main": [
        [
          {
            "node": "Add s3Url to JSON",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Add s3Url to JSON": {
      "main": [
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Google Gemini Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Binary Data Extraction": {
      "main": [
        [
          {
            "node": "Extract from File1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract from File1": {
      "main": [
        [
          {
            "node": "AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "PDFco Api": {
      "main": [
        [
          {
            "node": "Add File name to JSON",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dropbox": {
      "main": [
        [
          {
            "node": "PDFco Api",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract from File": {
      "main": [
        [
          {
            "node": "Dropbox",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "pinData": {},
  "versionId": "6cb2e6b9-ee73-4385-aa6a-e7f3ed7699d3",
  "triggerCount": 1,
  "tags": []
}